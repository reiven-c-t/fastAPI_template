from dataclasses import dataclass
from pathlib import Path
from typing import Any, List, Literal, Optional

value_types = {"integer": "int", "text": "str", "boolean": "bool", "datetime": "DateTime", "float": "float"}
VALUE_TYPE = Literal["integer", "text", "boolean", "date", "datetime", "timestamp", "float"]

schema_template = """# autogenerated by db_gen
from typing import Optional

from pydantic import BaseModel


# Shared properties
class {model}Base(BaseModel):
{columns}



# Properties to receive on {model_lower} creation
class {model}Create({model}Base):
    pass


# Properties to receive on {model_lower} update
class {model}Update({model}Base):
    pass


# Properties shared by models stored in DB
class {model}InDBBase({model}Base):
    id: int

    class Config:
        orm_mode = True


# Properties to return to client
class {model}({model}InDBBase):
    pass


# Properties stored in DB
class {model}InDB({model}InDBBase):
    pass
"""

crud_template = """# generated
from cruds.base import CRUDBase
from models.{model_lower} import {model}
from schemas.{model_lower} import {model}Create, {model}Update


class CRUD{model}(CRUDBase[{model}, {model}Create, {model}Update]):
    pass

{model_lower} = CRUD{model}({model})
"""

endpoint_template = '''# generated
from typing import Any, List, Optional

import cruds
import schemas
from api import deps
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session

router = APIRouter()

@router.post("/", response_model=schemas.{model})
def create_{model_lower}(
    {model_lower}_in: schemas.{model}Create,
    db: Session = Depends(deps.get_db),
) -> Any:
    {model_lower} = cruds.{model_lower}.create(db, {model_lower}_in)
    return {model_lower}


@router.get("/", response_model=List[schemas.{model}])
def read_{model_lower}(
    db: Session = Depends(deps.get_db),
    skip: int = 0,
    limit: int = 100,
) -> Any:
    {model_lower}s = cruds.{model_lower}.read(db, skip=skip, limit=limit)
    return {model_lower}s


@router.get("/{key}={value}", response_model=Optional[schemas.{model}])
def read_one_by_value(
    key: str,
    value: Any,
    db: Session = Depends(deps.get_db),
) -> Any:
    {model_lower} = cruds.{model_lower}.read_one_by_value(db, key=key, value=value)
    return {model_lower}


@router.put("/{id}", response_model=schemas.{model})
def update_{model_lower}(
    *,
    db: Session = Depends(deps.get_db),
    id: int,
    {model_lower}_in: schemas.{model}Update,
) -> Any:
    """
    Update an {model_lower}.
    """
    {model_lower} = cruds.{model_lower}.read_one_by_id(db=db, id=id)
    if not {model_lower}:
        raise HTTPException(status_code=404, detail="{model} not found")
    {model_lower} = cruds.{model_lower}.update(db=db, db_obj={model_lower}, obj_in={model_lower}_in)
    return {model_lower}


@router.delete("/{id}", response_model=schemas.{model})
def delete_{model_lower}(
    *,
    db: Session = Depends(deps.get_db),
    id: int,
) -> Any:
    """
    Delete an {model_lower}.
    """
    {model_lower} = cruds.{model_lower}.read_one_by_id(db=db, id=id)
    if not {model_lower}:
        raise HTTPException(status_code=404, detail="{model} not found")
    {model_lower} = cruds.{model_lower}.delete(db=db, id=id)
    return {model_lower}
'''


@dataclass
class Column:
    key: str
    value_type: VALUE_TYPE
    nullable: bool = True
    default: Optional[Any] = None


class DBGen:
    def __init__(self, filepath: str):
        self.filepath = Path(filepath)
        self.model_lower = self.filepath.name.replace(".py", "")
        self.model = "".join([i.capitalize() for i in self.model_lower.split("_")])

    def _read_model_class(self, filepath: Path) -> List[Column]:
        with open(filepath) as f:
            source = f.read()
            if source.find("from db.base_class import Base") == -1:
                raise ValueError("Not a Model class")
            class_begin = False
            columns = []
            for line in source.split("\n"):
                line = line.strip()
                if line.find("class") != -1 and line.find("(Base)") != -1:
                    class_begin = True
                    continue
                if class_begin:
                    if line.find("Column(") != -1:
                        key = line.split("=")[0].strip()
                        line = line[line.find("(") :]  # noqa
                        nullable = True
                        if line.find("nullable=False") != -1:
                            nullable = False
                        default = None
                        if line.find("default=") != -1:
                            for param in line.split(","):
                                param = param.replace(")", "")
                                if param.find("default=") != -1:
                                    default = param.replace("default=", "").strip()
                        for value_type in value_types.keys():
                            if line.lower().find(value_type) != -1:
                                columns.append(
                                    Column(key=key, value_type=value_type, nullable=nullable, default=default)
                                )

        return columns

    def _generate_schema(self, model: str, model_lower: str, columns: List[Column]) -> str:
        column_scripts = []
        for column in columns:
            if column.key == "id":
                continue
            value = value_types[column.value_type]
            if column.nullable:
                value = f"Optional[{value}]"
            if column.default is not None:
                value = f"{value} = {column.default}"
            column_script = f"\t{column.key}: {value}"
            column_scripts.append(column_script)
        columns = "\n".join(column_scripts)
        schema = schema_template.format(model=model, model_lower=model_lower, columns=columns)
        return schema

    def _generate_crud(self, model: str, model_lower: str) -> str:
        return crud_template.format(model=model, model_lower=model_lower)

    def _generate_endpoint(self, model: str, model_lower: str) -> str:
        return endpoint_template.replace("{model}", model).replace("{model_lower}", model_lower)

    def _insert_import(self, filepath: Path, import_line: str):
        with open(filepath) as fr, open(filepath, "a") as fw:
            imported = False
            for line in fr.read().split("\n"):
                line = line.strip()

                if line.find(import_line) != -1:
                    imported = True
                    break
            if not imported:
                fw.write(f"\n{import_line}  # noqa")

    def _write(self, filepath: Path, src: str):
        if not filepath.exists():
            with open(filepath, "w") as f:
                f.write(src)

    def main(self):
        src_top = self.filepath.parent.parent
        columns = self._read_model_class(self.filepath)
        schemas = self._generate_schema(self.model, self.model_lower, columns)
        cruds = self._generate_crud(self.model, self.model_lower)
        endpoints = self._generate_endpoint(self.model, self.model_lower)
        self._insert_import(
            filepath=src_top / "db" / "base.py", import_line=f"from models.{self.model_lower} import {self.model}"
        )
        self._insert_import(
            filepath=src_top / "cruds" / "__init__.py",
            import_line=f"from .crud_{self.model_lower} import {self.model_lower}",
        )
        self._insert_import(
            filepath=src_top / "schemas" / "__init__.py",
            import_line=f"from .{self.model_lower} import {self.model}, {self.model}Create, {self.model}InDB, {self.model}Update",  # noqa
        )
        self._write(filepath=src_top / "cruds" / f"crud_{self.model_lower}.py", src=cruds)
        self._write(filepath=src_top / "schemas" / f"{self.model_lower}.py", src=schemas)
        self._write(filepath=src_top / "api" / "v1" / "endpoints" / f"{self.model_lower}s.py", src=endpoints)


if __name__ == "__main__":
    DBGen("/Users/reiven/Documents/Python/fastAPITemplate/server/models/dummy.py").main()
